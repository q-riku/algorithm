"""
11.1 树与二叉树

11.1.1 树
·树是一种数据结构（e.g.目录结构）
·树是一种可以递归定义的数据结构
·树是由n个节点组成的集合：
    如果n=0，那这是一棵空树；
    如果n>0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树
·一些概念：
    根节点、叶子节点（没分叉的节点）
    树的深度（高度）：即最深有几层
    树的度：树里最大节点的度
    节点的度：节点分叉数
    子节点、父节点
    子树
-------------------------------------------------------------------------------
11.1.2 二叉树
·二叉树：度不超过2的树
·每个节点最多有两个子节点
·两个子节点被区分为左子节点和右子节点
·满二叉树：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树
                1
               /\
          2          3
         /\         /\
      4    5     6     7
     /\   /\    /\    /\
    8 9 10 11 12 13 14 15
·完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树
                1
               /\
          2          3
         /\         /\
      4    5     6     7
     /\   /\    /
    8 9 10 11 12
-------------------------------------------------------------------------------
11.1.3 二叉树的存储方式
·链式存储方式（*后期）
·顺序存储方式（列表存储方式）
    父节点和左子节点的编号下标的关系：i->2i+1
    父节点和右子节点的编号下标的关系：i->2i+2
    子节点->父节点：i->(i-1)//2

===============================================================================
11.2 堆排序

11.2.1 什么是堆
·堆：一种特殊的完全二叉树结构
    大根堆：一棵完全二叉树，满足任一节点都比其子节点大
              9
             /\
         8       7
        /\      /\
      6   5   0   1
     /\  /
    2 4 3
    小根堆：一棵完全二叉树，满足任一节点都比其子节点小
              1
             /\
         2       6
        /\      /\
      3   5   7   9
     /\  /
    4 6 8
·堆的向下调整性质
    当根节点的左右 子树都是堆但自身不是堆时，可以通过一次向下的调整来将其变换成一个堆
·时间复杂度：O(nlogn)
-------------------------------------------------------------------------------
11.2.2 堆排序过程
·1.建立堆
·2.得到堆顶元素，为最大元素
·3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序
·4堆顶元素为第二大元素
·5.重复步骤3，直到堆变空
-------------------------------------------------------------------------------
11.2.3 内置模块
·Python内置模块--heapq
    import heapq
·常用函数
    heapify(x)
    heappush(heap,item)
    heappop(heap)

===============================================================================
===============================================================================
"""


# ========== example ==========
def sift(li, low, high):
    """
    :param li:列表
    :param low:堆的根节点位置
    :param high:堆的最后一个元素的位置
    """
    i = low  # i最开始指向根节点
    j = 2 * i + 1  # j是左子节点
    tmp = li[low]  # 把堆顶存起来
    while j <= high:  # 只要j位置有数
        if j + 1 <= high and li[j + 1] > li[j]:  # 如果右子节点比较大
            j = j + 1  # j指向右子节点
        if li[j] > tmp:
            li[i] = li[j]
            i = j  # 往下看一层
            j = 2 * i + 1
        else:  # tmp更大
            li[i] = tmp  # 把tmp放到某一级领导的位置上
            break
    else:
        li[i] = tmp  # 把tmp放到叶子节点上


def heap_sort(li):
    n = len(li)
    for i in range((n - 2) // 2, -1, -1):  # i表示建堆的时候调整的部分的根的下标
        sift(li, i, n - 1)  # 建堆完成
    for i in range(n - 1, -1, -1):  # i指向当前堆的最后一个元素
        li[0], li[i] = li[i], li[0]
        sift(li, 0, i - 1)  # i-1是新的high


li = [6, 8, 1, 9, 3, 0, 7, 2, 4, 5]
heap_sort(li)
print(li)


# ========== heapq ==========
import heapq  # q-->queue优先队列
import random

li2 = list(range(100))
random.shuffle(li2)

print(li2)

heapq.heapify(li2)  # 建堆，默认建小根堆
# print(li2)

for i in range(len(li2)):
    print(heapq.heappop(li2), end=',')  # 每次弹出最小的值
