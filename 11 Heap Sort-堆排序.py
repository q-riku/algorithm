"""
11.1 树与二叉树

11.1.1 树
·树是一种数据结构（e.g.目录结构）
·树是一种可以递归定义的数据结构
·树是由n个节点组成的集合：
    如果n=0，那这是一棵空树；
    如果n>0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一棵树
·一些概念：
    根节点、叶子节点（没分叉的节点）
    树的深度（高度）：即最深有几层
    树的度：树里最大节点的度
    节点的度：节点分叉数
    子节点、父节点
    子树
-------------------------------------------------------------------------------
11.1.2 二叉树
·二叉树：度不超过2的树
·每个节点最多有两个子节点
·两个子节点被区分为左子节点和右子节点
·满二叉树：一个二叉树，如果每一层的节点数都达到最大值，则这个二叉树就是满二叉树
                1
               /\
          2          3
         /\         /\
      4    5     6     7
     /\   /\    /\    /\
    8 9 10 11 12 13 14 15
·完全二叉树：叶节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树
                1
               /\
          2          3
         /\         /\
      4    5     6     7
     /\   /\    /
    8 9 10 11 12
-------------------------------------------------------------------------------
11.1.3 二叉树的存储方式
·链式存储方式（*后期）
·顺序存储方式（列表存储方式）
    父节点和左子节点的编号下标的关系：i->2i+1
    父节点和右子节点的编号下标的关系：i->2i+2
    子节点->父节点：i->(i-1)//2

===============================================================================
11.2 堆排序

11.2.1 什么是堆
·堆：一种特殊的完全二叉树结构
    大根堆：一棵完全二叉树，满足任一节点都比其子节点大
              9
             /\
         8       7
        /\      /\
      6   5   0   1
     /\  /
    2 4 3
    小根堆：一棵完全二叉树，满足任一节点都比其子节点小
              1
             /\
         2       6
        /\      /\
      3   5   7   9
     /\  /
    4 6 8
·堆的向下调整性质
    当根节点的左右 子树都是堆但自身不是堆时，可以通过一次向下的调整来将其变换成一个堆
-------------------------------------------------------------------------------
11.2.2 堆排序过程
·1.建立堆
·2.得到堆顶元素，为最大元素
·3.去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序
·4堆顶元素为第二大元素
·5.重复步骤3，直到堆变空
"""


# ========== example ==========
def sift(li, low, high):
    """
    :param li:列表
    :param low:堆的根节点位置
    :param high:堆的最后一个元素的位置
    """
    i = low  # i最开始指向根节点
    j = 2*i + 1  # j是左子节点
    tmp = li[low]  # 把堆顶存起来
    while j <= high: # 只要j位置有数
        if j + 1 <= high and li[j+1] > li[j]:  # 如果右子节点比较大
            j = j + 1  # j指向右子节点
        if li[j] > tmp:
            li[i] = li[j]
            i = j  # 往下看一层
            j = 2 * i + 1
        else:  # tmp更大
            li[i] = tmp  # 把tmp放到某一级领导的位置上
            break
    else:
        li[i] = tmp  # 把tmp放到叶子节点上

